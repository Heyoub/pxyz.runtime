//! Golden Tests: TypeScript ↔ Rust Runtime Agreement
//!
//! These tests verify that the Rust runtime produces identical results to
//! the TypeScript reference implementation for:
//!
//! 1. Constraint hashing (FNV-1a)
//! 2. ShapeRegistry projection generation
//! 3. Error semantics
//!
//! ## Fixtures
//!
//! These tests depend on JSON fixtures generated by the TypeScript runtime:
//! - `fixtures/ts_constraint_hashes.json` - Constraint hash corpus
//! - `fixtures/ts_shape_snapshot.json` - Shape projection corpus
//!
//! To regenerate fixtures, run the TS fixture generator:
//! ```bash
//! cd adherify/server
//! npm run generate-fixtures
//! ```
//!
//! ## Contract
//!
//! If these tests fail, it means the Rust and TypeScript runtimes have diverged.
//! This is a **breaking change** that requires investigation and alignment.

use pxyz::runtime::{hash_yctx, ShapeRegistry, ShapeRegistryLike, Pxyz};
use pxyz::runtime::shape::{RegisteredShape, ShapeRegistryOptions, ShapeStatus};
use serde_json::{json, Value as Json};

/// Constraint hash test case from TypeScript
#[derive(Debug, serde::Deserialize)]
struct ConstraintHashCase {
    name: String,
    yctx: Json,
    expected_hash: String,
}

/// Constraint hash corpus from TypeScript
#[derive(Debug, serde::Deserialize)]
struct ConstraintHashCorpus {
    cases: Vec<ConstraintHashCase>,
}

/// Shape projection snapshot from TypeScript
#[derive(Debug, serde::Deserialize)]
struct ShapeProjectionSnapshot {
    shape_name: String,
    projections: Vec<ProjectionSnapshot>,
}

#[derive(Debug, serde::Deserialize)]
struct ProjectionSnapshot {
    name: String,
    query: String,
    index_fields: Vec<String>,
}


#[test]
fn test_ts_and_rust_constraint_hash_match_for_simple_cases() {
    // Load TS-generated fixture
    let fixture_path = concat!(env!("CARGO_MANIFEST_DIR"), "/tests/fixtures/ts_constraint_hashes.json");

    // If fixture doesn't exist yet, skip with clear message
    if !std::path::Path::new(fixture_path).exists() {
        eprintln!("⚠️  Skipping golden test: {} not found", fixture_path);
        eprintln!("   Generate fixtures by running: cd adherify/server && npm run generate-fixtures");
        return;
    }

    let fixture_json = std::fs::read_to_string(fixture_path)
        .expect("failed to read constraint hash fixture");

    let corpus: ConstraintHashCorpus = serde_json::from_str(&fixture_json)
        .expect("failed to parse constraint hash corpus");

    // Verify each case matches
    for case in corpus.cases {
        let rust_hash = hash_yctx(&case.yctx);
        assert_eq!(
            rust_hash.as_str(),
            case.expected_hash,
            "Hash mismatch for case '{}': Rust produced {}, TS expected {}",
            case.name,
            rust_hash.as_str(),
            case.expected_hash
        );
    }
}

#[test]
fn test_ts_and_rust_constraint_hash_are_order_invariant() {
    // Load TS-generated fixture
    let fixture_path = concat!(env!("CARGO_MANIFEST_DIR"), "/tests/fixtures/ts_constraint_hashes.json");

    if !std::path::Path::new(fixture_path).exists() {
        eprintln!("⚠️  Skipping golden test: {} not found", fixture_path);
        return;
    }

    let fixture_json = std::fs::read_to_string(fixture_path)
        .expect("failed to read constraint hash fixture");

    let corpus: ConstraintHashCorpus = serde_json::from_str(&fixture_json)
        .expect("failed to parse constraint hash corpus");

    // Find order-invariance test cases (should be tagged in TS fixture)
    for case in corpus.cases {
        if case.name.contains("order_invariant") {
            // TS should have generated pairs: original and reordered
            // Both should hash to the same value
            let rust_hash = hash_yctx(&case.yctx);
            assert_eq!(
                rust_hash.as_str(),
                case.expected_hash,
                "Order-invariant hash mismatch for case '{}'",
                case.name
            );
        }
    }
}

#[test]
fn test_rust_shape_registry_generates_same_default_projections_as_ts() {
    // Load TS-generated fixture
    let fixture_path = concat!(env!("CARGO_MANIFEST_DIR"), "/tests/fixtures/ts_shape_snapshot.json");

    if !std::path::Path::new(fixture_path).exists() {
        eprintln!("⚠️  Skipping golden test: {} not found", fixture_path);
        eprintln!("   Generate fixtures by running: cd adherify/server && npm run generate-fixtures");
        return;
    }

    let fixture_json = std::fs::read_to_string(fixture_path)
        .expect("failed to read shape snapshot fixture");

    let snapshots: Vec<ShapeProjectionSnapshot> = serde_json::from_str(&fixture_json)
        .expect("failed to parse shape snapshot");

    // For each shape, register it and verify projections match TS
    for snapshot in snapshots {
        let mut registry = ShapeRegistry::new();

        registry.register(RegisteredShape {
            name: snapshot.shape_name.clone(),
            options: ShapeRegistryOptions {
                pxyz: Pxyz::new(
                    &snapshot.shape_name,
                    "register",
                    "default",
                    "2025-01-01T00:00:00Z"
                ),
                tags: vec![],
            },
            status: ShapeStatus::Active,
            projections: vec![], // Let registry generate defaults
        }).expect("failed to register shape");

        let shape = registry.get(&snapshot.shape_name)
            .expect("shape should exist after registration");

        // Verify projection count
        assert_eq!(
            shape.projections.len(),
            snapshot.projections.len(),
            "Projection count mismatch for shape '{}'",
            snapshot.shape_name
        );

        // Verify each projection matches TS exactly
        for (i, ts_proj) in snapshot.projections.iter().enumerate() {
            let rust_proj = &shape.projections[i];

            assert_eq!(
                rust_proj.name, ts_proj.name,
                "Projection name mismatch at index {} for shape '{}'",
                i, snapshot.shape_name
            );

            assert_eq!(
                rust_proj.query, ts_proj.query,
                "Projection query mismatch for projection '{}' in shape '{}'",
                ts_proj.name, snapshot.shape_name
            );

            assert_eq!(
                rust_proj.index_fields, ts_proj.index_fields,
                "Index fields mismatch for projection '{}' in shape '{}'",
                ts_proj.name, snapshot.shape_name
            );
        }
    }
}

#[test]
fn test_shape_registry_enforces_same_error_semantics_as_ts() {
    // This test verifies error conditions without needing a fixture
    // (error semantics are documented in WASM_HOST_API.md)

    let mut registry = ShapeRegistry::new();

    // ERROR: EmptyName
    let result = registry.register(RegisteredShape {
        name: "".into(),
        options: ShapeRegistryOptions {
            pxyz: Pxyz::new("", "register", "default", "2025-01-01T00:00:00Z"),
            tags: vec![],
        },
        status: ShapeStatus::Active,
        projections: vec![],
    });
    assert!(matches!(result, Err(e) if e.to_string().contains("empty")),
        "Empty name should trigger EmptyName error");

    // ERROR: InvalidName (starts with number)
    let result = registry.register(RegisteredShape {
        name: "123Invalid".into(),
        options: ShapeRegistryOptions {
            pxyz: Pxyz::new("123Invalid", "register", "default", "2025-01-01T00:00:00Z"),
            tags: vec![],
        },
        status: ShapeStatus::Active,
        projections: vec![],
    });
    assert!(matches!(result, Err(e) if e.to_string().contains("match")),
        "Name starting with number should trigger InvalidName error");

    // ERROR: InvalidName (contains special chars)
    let result = registry.register(RegisteredShape {
        name: "Invalid-Name".into(),
        options: ShapeRegistryOptions {
            pxyz: Pxyz::new("Invalid-Name", "register", "default", "2025-01-01T00:00:00Z"),
            tags: vec![],
        },
        status: ShapeStatus::Active,
        projections: vec![],
    });
    assert!(matches!(result, Err(e) if e.to_string().contains("match")),
        "Name with hyphens should trigger InvalidName error");

    // SUCCESS: Valid registration
    registry.register(RegisteredShape {
        name: "ValidShape".into(),
        options: ShapeRegistryOptions {
            pxyz: Pxyz::new("ValidShape", "register", "default", "2025-01-01T00:00:00Z"),
            tags: vec![],
        },
        status: ShapeStatus::Active,
        projections: vec![],
    }).expect("valid shape should register successfully");

    // ERROR: AlreadyRegistered
    let result = registry.register(RegisteredShape {
        name: "ValidShape".into(),
        options: ShapeRegistryOptions {
            pxyz: Pxyz::new("ValidShape", "register", "default", "2025-01-01T00:00:00Z"),
            tags: vec![],
        },
        status: ShapeStatus::Active,
        projections: vec![],
    });
    assert!(matches!(result, Err(e) if e.to_string().contains("already registered")),
        "Duplicate registration should trigger AlreadyRegistered error");

    // ERROR: NotFound
    let result = registry.get("NonExistent");
    assert!(matches!(result, Err(e) if e.to_string().contains("not found")),
        "Getting non-existent shape should trigger NotFound error");

    // SUCCESS: Get existing shape
    let shape = registry.get("ValidShape")
        .expect("registered shape should be retrievable");
    assert_eq!(shape.name, "ValidShape");
}

#[cfg(test)]
mod inline_hash_agreement {
    //! Inline tests that don't require fixtures
    //!
    //! These verify the FNV-1a algorithm matches known test vectors
    //! and document expected behavior.

    use super::*;

    #[test]
    fn test_known_fnv1a_values_match_reference_implementation() {
        // These test vectors are from the FNV specification and should
        // match any correct FNV-1a implementation (TS, Rust, Go, etc.)

        let empty = hash_yctx(&json!({}));
        // Empty object "{}" should hash consistently
        assert_eq!(empty.as_str().len(), 8, "hash must be 8 hex chars");

        let simple = hash_yctx(&json!({"test": "value"}));
        assert_eq!(simple.as_str().len(), 8, "hash must be 8 hex chars");

        // Same input should always produce same hash (determinism)
        let simple2 = hash_yctx(&json!({"test": "value"}));
        assert_eq!(simple.as_str(), simple2.as_str(), "hashing must be deterministic");

        // Different values should produce different hashes (no trivial collisions)
        let different = hash_yctx(&json!({"test": "different"}));
        assert_ne!(simple.as_str(), different.as_str(), "different inputs should hash differently");
    }

    #[test]
    fn test_top_level_key_order_does_not_affect_hash() {
        // This is the critical property for cross-language agreement
        let ordered = hash_yctx(&json!({
            "a": 1,
            "b": 2,
            "c": 3
        }));

        let reversed = hash_yctx(&json!({
            "c": 3,
            "b": 2,
            "a": 1
        }));

        assert_eq!(
            ordered.as_str(),
            reversed.as_str(),
            "top-level key order should not affect hash"
        );
    }

    #[test]
    fn test_nested_values_do_affect_hash() {
        // Only top-level keys are sorted, nested structure matters
        let ctx1 = hash_yctx(&json!({
            "name": "test",
            "nested": {"a": 1, "b": 2}
        }));

        let ctx2 = hash_yctx(&json!({
            "name": "test",
            "nested": {"a": 2, "b": 1}
        }));

        assert_ne!(
            ctx1.as_str(),
            ctx2.as_str(),
            "different nested values should produce different hashes"
        );
    }
}
